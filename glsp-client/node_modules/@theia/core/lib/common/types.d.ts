export declare type Mutable<T> = {
    -readonly [P in keyof T]: T[P];
};
export declare type MaybeNull<T> = {
    [P in keyof T]: T[P] | null;
};
export declare type MaybeUndefined<T> = {
    [P in keyof T]: T[P] | undefined;
};
/**
 * Creates a shallow copy with all ownkeys of the original object that are `null` made `undefined`
 */
export declare function nullToUndefined<T>(nullable: MaybeNull<T>): MaybeUndefined<T>;
export declare type Deferred<T> = {
    [P in keyof T]: Promise<T[P]>;
};
export declare type RecursivePartial<T> = {
    [P in keyof T]?: T[P] extends Array<infer I> ? Array<RecursivePartial<I>> : RecursivePartial<T[P]>;
};
export declare type MaybeArray<T> = T | T[];
export declare type MaybePromise<T> = T | PromiseLike<T>;
export interface Prioritizeable<T> {
    readonly priority: number;
    readonly value: T;
}
export declare namespace Prioritizeable {
    type GetPriority<T> = (value: T) => MaybePromise<number>;
    type GetPrioritySync<T> = (value: T) => number;
    function toPrioritizeable<T>(rawValue: MaybePromise<T>, getPriority: GetPriority<T>): Promise<Prioritizeable<T>>;
    function toPrioritizeable<T>(rawValue: MaybePromise<T>[], getPriority: GetPriority<T>): Promise<Prioritizeable<T>[]>;
    function toPrioritizeableSync<T>(rawValue: T[], getPriority: GetPrioritySync<T>): Prioritizeable<T>[];
    function prioritizeAllSync<T>(values: T[], getPriority: GetPrioritySync<T>): Prioritizeable<T>[];
    function prioritizeAll<T>(values: MaybePromise<T>[], getPriority: GetPriority<T>): Promise<Prioritizeable<T>[]>;
    function isValid<T>(p: Prioritizeable<T>): boolean;
    function compare<T>(p: Prioritizeable<T>, p2: Prioritizeable<T>): number;
}
export declare namespace ArrayUtils {
    interface Head<T> extends Array<T> {
        head(): T;
    }
    interface Tail<T> extends Array<T> {
        tail(): T;
    }
    interface Children<T> extends Array<T> {
        children(): Tail<T>;
    }
    const TailImpl: {
        tail<T>(this: T[]): T;
    };
    const HeadAndChildrenImpl: {
        head<T>(this: T[]): T;
        children<T_1>(this: T_1[]): Tail<T_1>;
    };
    interface HeadAndTail<T> extends Head<T>, Tail<T>, Children<T> {
    }
    function asTail<T>(array: Array<T>): Tail<T>;
    function asHeadAndTail<T>(array: Array<T>): HeadAndTail<T>;
}
/**
 * Throws when called and statically makes sure that all variants of a type were consumed.
 */
export declare function unreachable(_never: never, message?: string): never;
//# sourceMappingURL=types.d.ts.map