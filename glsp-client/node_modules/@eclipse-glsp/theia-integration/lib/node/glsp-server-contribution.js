"use strict";
/********************************************************************************
 * Copyright (C) 2017-2022 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
/* eslint-disable indent */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseGLSPServerContribution = exports.GLSPServerContributionOptions = exports.GLSPServerContribution = void 0;
const messaging_1 = require("@theia/core/lib/node/messaging");
const inversify_1 = require("@theia/core/shared/inversify");
const process_manager_1 = require("@theia/process/lib/node/process-manager");
const raw_process_1 = require("@theia/process/lib/node/raw-process");
const server_1 = require("vscode-ws-jsonrpc/lib/server");
exports.GLSPServerContribution = Symbol.for('GLSPServerContribution');
var GLSPServerContributionOptions;
(function (GLSPServerContributionOptions) {
    /** Default values for {@link GLSPServerContributionOptions } **/
    function createDefaultOptions() {
        return {
            launchOnDemand: false,
            launchedExternally: inDebugMode()
        };
    }
    GLSPServerContributionOptions.createDefaultOptions = createDefaultOptions;
    /**
     * Utility function to partially set the launch options. Default values (from 'defaultOptions') are used for
     * options that are not specified.
     * @param options (partial) launch options that should be extended with default values (if necessary).
     */
    function configure(options) {
        return options
            ? Object.assign(Object.assign({}, createDefaultOptions()), options)
            : createDefaultOptions();
    }
    GLSPServerContributionOptions.configure = configure;
    GLSPServerContributionOptions.debugArgument = '--debug';
    /**
     * Utility function which specifies if the Theia application has been started in debug mode.
     * i.e. if the '--debug' flag has been passed.
     * @returns `true` if the '--debug' flag has been set.
     */
    function inDebugMode() {
        const args = process.argv.filter(a => a.toLowerCase().startsWith(GLSPServerContributionOptions.debugArgument.toLowerCase()));
        return args.length > 0;
    }
    GLSPServerContributionOptions.inDebugMode = inDebugMode;
    /**
     * Utility function that processes the contribution launch options to determine wether the server should be launched on
     * application start.
     * @param contribution The glsp server contribution.
     * @returns `true` if the server should be launched on application start.
     */
    function shouldLaunchOnApplicationStart(contribution) {
        return contribution.launch !== undefined && !contribution.options.launchOnDemand && !contribution.options.launchedExternally;
    }
    GLSPServerContributionOptions.shouldLaunchOnApplicationStart = shouldLaunchOnApplicationStart;
})(GLSPServerContributionOptions = exports.GLSPServerContributionOptions || (exports.GLSPServerContributionOptions = {}));
/**
 * A base implementation of {@link GLSPServerContribution} that provides utility methods for forwarding
 *  (frontend) client connections to a GLSP server and for spawning new server processes.
 */
let BaseGLSPServerContribution = class BaseGLSPServerContribution {
    initialize() {
        this.options = this.createContributionOptions
            ? GLSPServerContributionOptions.configure(this.createContributionOptions())
            : GLSPServerContributionOptions.createDefaultOptions();
    }
    forward(clientConnection, serverConnection) {
        (0, server_1.forward)(clientConnection, serverConnection);
        if (messaging_1.WebSocketChannelConnection.is(clientConnection)) {
            serverConnection.onClose(() => clientConnection.channel.tryClose());
        }
    }
    spawnProcessAsync(command, args, options) {
        const rawProcess = this.processFactory({ command, args, options });
        rawProcess.errorStream.on('data', this.processLogError.bind(this));
        rawProcess.outputStream.on('data', this.processLogInfo.bind(this));
        return new Promise((resolve, reject) => {
            rawProcess.onError((error) => {
                this.onDidFailSpawnProcess(error);
                if (error.code === 'ENOENT') {
                    const guess = command.split(/\s+/).shift();
                    if (guess) {
                        reject(new Error(`Failed to spawn ${guess}\nPerhaps it is not on the PATH.`));
                        return;
                    }
                }
                reject(error);
            });
            process.nextTick(() => resolve(rawProcess));
        });
    }
    onDidFailSpawnProcess(error) {
        console.error(error);
    }
    processLogError(data) {
        if (data) {
            console.error(`${this.id}: ${data}`);
        }
    }
    processLogInfo(data) {
        if (data) {
            console.info(`${this.id}: ${data}`);
        }
    }
};
__decorate([
    (0, inversify_1.inject)(raw_process_1.RawProcessFactory),
    __metadata("design:type", Function)
], BaseGLSPServerContribution.prototype, "processFactory", void 0);
__decorate([
    (0, inversify_1.inject)(process_manager_1.ProcessManager),
    __metadata("design:type", process_manager_1.ProcessManager)
], BaseGLSPServerContribution.prototype, "processManager", void 0);
__decorate([
    (0, inversify_1.postConstruct)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], BaseGLSPServerContribution.prototype, "initialize", null);
BaseGLSPServerContribution = __decorate([
    (0, inversify_1.injectable)()
], BaseGLSPServerContribution);
exports.BaseGLSPServerContribution = BaseGLSPServerContribution;
//# sourceMappingURL=glsp-server-contribution.js.map