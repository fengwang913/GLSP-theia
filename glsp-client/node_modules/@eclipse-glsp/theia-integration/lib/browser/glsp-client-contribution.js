"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseGLSPClientContribution = exports.GLSPClientContribution = void 0;
/********************************************************************************
 * Copyright (C) 2017-2021 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const client_1 = require("@eclipse-glsp/client");
const core_1 = require("@theia/core");
const browser_1 = require("@theia/core/lib/browser");
const inversify_1 = require("@theia/core/shared/inversify");
const browser_2 = require("@theia/workspace/lib/browser");
const sprotty_theia_1 = require("sprotty-theia");
require("sprotty-theia/css/theia-sprotty.css");
require("sprotty/css/sprotty.css");
require("../../css/command-palette.css");
require("../../css/decoration.css");
require("../../css/diagram.css");
require("../../css/theia-dialogs.css");
require("../../css/tool-palette.css");
const common_1 = require("../common");
const theia_jsonrpc_glsp_client_1 = require("./theia-jsonrpc-glsp-client");
exports.GLSPClientContribution = Symbol.for('GLSPClientContribution');
let BaseGLSPClientContribution = class BaseGLSPClientContribution {
    constructor() {
        this.toDeactivate = new core_1.DisposableCollection();
        this.waitForReady();
    }
    get glspClient() {
        return this._glspClient ? Promise.resolve(this._glspClient) : this.ready;
    }
    get initializeResult() {
        return this.glspClient.then(_client => {
            if (!this._initializeResult) {
                throw new Error('Server is not yet initialized!');
            }
            return this._initializeResult;
        });
    }
    waitForActivation(app) {
        const activationPromises = [];
        const workspaceContains = this.workspaceContains;
        if (workspaceContains.length !== 0) {
            activationPromises.push(this.waitForItemInWorkspace());
        }
        if (activationPromises.length !== 0) {
            return Promise.all([
                this.ready,
                Promise.race(activationPromises.map(p => 
                // eslint-disable-next-line no-async-promise-executor
                new Promise(async (resolve) => {
                    try {
                        await p;
                        resolve();
                    }
                    catch (e) {
                        console.error(e);
                    }
                })))
            ]);
        }
        return this.ready;
    }
    activate() {
        if (this.toDeactivate.disposed) {
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            this.toDeactivate.push(new core_1.DisposableCollection(core_1.Disposable.create(() => { }))); // mark as not disposed
            this.doActivate(this.toDeactivate);
        }
        return this.toDeactivate;
    }
    deactivate(_app) {
        this.toDeactivate.dispose();
    }
    async doActivate(toStop) {
        try {
            this.connectionProvider.listen({
                path: common_1.GLSPContribution.getPath(this),
                onConnection: messageConnection => {
                    if (toStop.disposed) {
                        messageConnection.dispose();
                        return;
                    }
                    const languageClient = this.createGLSPCLient(messageConnection);
                    this.onWillStart(languageClient);
                    toStop.pushAll([
                        messageConnection,
                        core_1.Disposable.create(() => {
                            languageClient.shutdownServer();
                            languageClient.stop();
                        })
                    ]);
                }
            }, { reconnecting: false });
        }
        catch (e) {
            console.error(e);
        }
    }
    get running() {
        return !this.toDeactivate.disposed && this._glspClient !== undefined && this._glspClient.currentState === client_1.ClientState.Running;
    }
    async onWillStart(languageClient) {
        await languageClient.start();
        this._initializeResult = await this.initialize(languageClient);
        this.onReady(languageClient);
    }
    async initialize(languageClient) {
        try {
            const parameters = await this.createInitializeParameters();
            return await languageClient.initializeServer(parameters);
        }
        catch (error) {
            const errorMsg = `Failed to initialize ${this.id} glsp server with: ${error}`;
            this.messageService.error(errorMsg);
            return Promise.reject(errorMsg);
        }
    }
    async createInitializeParameters() {
        const args = await this.createInitializeOptions();
        return {
            applicationId: client_1.ApplicationIdProvider.get(),
            protocolVersion: client_1.GLSPClient.protocolVersion,
            args
        };
    }
    createInitializeOptions() {
        return undefined;
    }
    onReady(languageClient) {
        this._glspClient = languageClient;
        this.resolveReady(this._glspClient);
        this.waitForReady();
    }
    waitForReady() {
        this.ready = new Promise(resolve => (this.resolveReady = resolve));
    }
    createGLSPCLient(connectionProvider) {
        return new theia_jsonrpc_glsp_client_1.TheiaJsonrpcGLSPClient({
            id: this.id,
            connectionProvider,
            messageService: this.messageService
        });
    }
    get workspaceContains() {
        return [];
    }
    async waitForItemInWorkspace() {
        const doesContain = await this.workspaceService.containsSome(this.workspaceContains);
        if (!doesContain) {
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            return new Promise(resolve => { });
        }
        return doesContain;
    }
};
__decorate([
    (0, inversify_1.inject)(browser_2.WorkspaceService),
    __metadata("design:type", browser_2.WorkspaceService)
], BaseGLSPClientContribution.prototype, "workspaceService", void 0);
__decorate([
    (0, inversify_1.inject)(core_1.MessageService),
    __metadata("design:type", core_1.MessageService)
], BaseGLSPClientContribution.prototype, "messageService", void 0);
__decorate([
    (0, inversify_1.inject)(browser_1.WebSocketConnectionProvider),
    __metadata("design:type", browser_1.WebSocketConnectionProvider)
], BaseGLSPClientContribution.prototype, "connectionProvider", void 0);
__decorate([
    (0, inversify_1.multiInject)(sprotty_theia_1.DiagramManagerProvider),
    __metadata("design:type", Array)
], BaseGLSPClientContribution.prototype, "diagramManagerProviders", void 0);
BaseGLSPClientContribution = __decorate([
    (0, inversify_1.injectable)(),
    __metadata("design:paramtypes", [])
], BaseGLSPClientContribution);
exports.BaseGLSPClientContribution = BaseGLSPClientContribution;
//# sourceMappingURL=glsp-client-contribution.js.map