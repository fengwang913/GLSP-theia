"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SaveableGLSPModelSource = exports.getDiagramWidget = exports.GLSPDiagramWidget = void 0;
/********************************************************************************
 * Copyright (c) 2019-2022 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const client_1 = require("@eclipse-glsp/client");
const common_1 = require("@theia/core/lib/common");
const lodash_1 = require("lodash");
const sprotty_theia_1 = require("sprotty-theia");
const glsp_theia_diagram_server_1 = require("./glsp-theia-diagram-server");
class GLSPDiagramWidget extends sprotty_theia_1.DiagramWidget {
    constructor(options, widgetId, diContainer, editorPreferences, storage, theiaSelectionService, connector) {
        super(options, widgetId, diContainer, connector);
        this.widgetId = widgetId;
        this.diContainer = diContainer;
        this.editorPreferences = editorPreferences;
        this.storage = storage;
        this.theiaSelectionService = theiaSelectionService;
        this.connector = connector;
        this.storeViewportStateOnClose = true;
        this.saveable = new SaveableGLSPModelSource(this.actionDispatcher, this.diContainer.get(client_1.TYPES.ModelSource));
        this.updateSaveable();
        this.title.caption = this.uri.path.fsPath();
        const prefUpdater = editorPreferences.onPreferenceChanged(() => this.updateSaveable());
        this.toDispose.push(prefUpdater);
        this.toDispose.push(this.saveable);
    }
    updateSaveable() {
        this.saveable.autoSave = this.editorPreferences['files.autoSave'];
        this.saveable.autoSaveDelay = this.editorPreferences['files.autoSaveDelay'];
    }
    initializeSprotty() {
        const modelSource = this.diContainer.get(client_1.TYPES.ModelSource);
        if (modelSource instanceof client_1.DiagramServerProxy) {
            modelSource.clientId = this.id;
        }
        if (modelSource instanceof glsp_theia_diagram_server_1.GLSPTheiaDiagramServer) {
            this.connector.connect(modelSource);
        }
        this.disposed.connect(() => {
            if (modelSource instanceof glsp_theia_diagram_server_1.GLSPTheiaDiagramServer) {
                this.connector.disconnect(modelSource);
            }
        });
        // Filter options to only contain defined primitive values
        const definedOptions = (0, lodash_1.pickBy)(this.options, v => v !== undefined && typeof v !== 'object');
        this.requestModelOptions = Object.assign({ sourceUri: this.uri.path.fsPath() }, definedOptions);
        this.dispatchInitialActions();
    }
    dispatchInitialActions() {
        this.actionDispatcher.dispatch(client_1.RequestModelAction.create({ options: this.requestModelOptions }));
        this.actionDispatcher.dispatch(client_1.RequestTypeHintsAction.create());
        this.actionDispatcher.dispatch(client_1.EnableToolPaletteAction.create());
        this.actionDispatcher.dispatch(client_1.SetEditModeAction.create(this.options.editMode));
    }
    onAfterAttach(msg) {
        super.onAfterAttach(msg);
        this.node.dataset['uri'] = this.uri.toString();
        if (this.diContainer.isBound(client_1.TYPES.ICopyPasteHandler)) {
            this.copyPasteHandler = this.diContainer.get(client_1.TYPES.ICopyPasteHandler);
            this.addClipboardListener(this.node, 'copy', e => this.handleCopy(e));
            this.addClipboardListener(this.node, 'paste', e => this.handlePaste(e));
            this.addClipboardListener(this.node, 'cut', e => this.handleCut(e));
        }
        this.node.addEventListener('mouseenter', e => this.handleMouseEnter(e));
        this.node.addEventListener('mouseleave', e => this.handleMouseLeave(e));
    }
    onBeforeDetach(msg) {
        this.storeViewportDataInStorageService();
        this.node.removeEventListener('mouseenter', this.handleMouseEnter);
        this.node.removeEventListener('mouseleave', this.handleMouseLeave);
        super.onBeforeDetach(msg);
    }
    onCloseRequest(msg) {
        super.onCloseRequest(msg);
        this.clearGlobalSelection();
    }
    onActivateRequest(msg) {
        super.onActivateRequest(msg);
        this.updateGlobalSelection();
    }
    get diagramType() {
        return this.options.diagramType;
    }
    get editorContext() {
        return this.diContainer.get(client_1.EditorContextService);
    }
    reloadModel() {
        return this.actionDispatcher.dispatch(client_1.RequestModelAction.create({ options: this.requestModelOptions }));
    }
    handleMouseEnter(e) {
        this.node.classList.add('mouse-enter');
        this.node.classList.remove('mouse-leave');
    }
    handleMouseLeave(e) {
        this.node.classList.add('mouse-leave');
        this.node.classList.remove('mouse-enter');
    }
    handleCopy(e) {
        if (this.copyPasteHandler) {
            this.copyPasteHandler.handleCopy(e);
        }
    }
    handleCut(e) {
        if (this.copyPasteHandler) {
            this.copyPasteHandler.handleCut(e);
        }
    }
    handlePaste(e) {
        if (this.copyPasteHandler) {
            this.copyPasteHandler.handlePaste(e);
        }
    }
    listenToFocusState(shell) {
        this.toDispose.push(shell.onDidChangeActiveWidget(event => {
            const focusedWidget = event.newValue;
            if (this.hasFocus && focusedWidget && !this.isThisWidget(focusedWidget)) {
                this.actionDispatcher.dispatch(client_1.FocusStateChangedAction.create(false));
            }
            else if (!this.hasFocus && this.isThisWidget(focusedWidget)) {
                this.actionDispatcher.dispatch(client_1.FocusStateChangedAction.create(true));
            }
        }));
    }
    isThisWidget(widget) {
        // eslint-disable-next-line no-null/no-null
        if (!widget || widget === null) {
            return false;
        }
        const diagramWidget = getDiagramWidget(widget);
        return diagramWidget !== undefined && diagramWidget.id === this.id;
    }
    get hasFocus() {
        let focusTracker;
        if (this.diContainer.isBound(client_1.FocusTracker)) {
            focusTracker = this.diContainer.get(client_1.FocusTracker);
        }
        if (focusTracker) {
            return focusTracker.hasFocus;
        }
        return undefined;
    }
    async getSelectedElementIds() {
        const editorContextService = this.diContainer.get(client_1.EditorContextService);
        return editorContextService.selectedElements.map(element => element.id);
    }
    async updateGlobalSelection() {
        this.getSelectedElementIds().then((selectedElementsIDs) => this.actionDispatcher.dispatch(client_1.SelectAction.create({ selectedElementsIDs })));
    }
    async clearGlobalSelection() {
        this.theiaSelectionService.selection = undefined;
    }
    // eslint-disable-next-line @typescript-eslint/ban-types
    storeState() {
        // the viewport is stored in the application layout
        // so there is no need to keep it in the storage
        this.removeViewportDataFromStorageService();
        return Object.assign(Object.assign({}, super.storeState()), this.getViewportData());
    }
    // eslint-disable-next-line @typescript-eslint/ban-types
    restoreState(oldState) {
        super.restoreState(oldState);
        if (isViewportDataContainer(oldState)) {
            this.setViewportData(oldState);
        }
    }
    storeViewportDataInStorageService() {
        if (!this.storeViewportStateOnClose) {
            return;
        }
        const viewportData = this.getViewportData();
        if (viewportData) {
            this.storage.setData(this.viewportStorageId, viewportData);
        }
    }
    async restoreViewportDataFromStorageService() {
        if (!this.storeViewportStateOnClose) {
            return;
        }
        const viewportData = await this.storage.getData(this.viewportStorageId);
        if (viewportData) {
            this.setViewportData(viewportData);
        }
    }
    async removeViewportDataFromStorageService() {
        return this.storage.setData(this.viewportStorageId, undefined);
    }
    get viewportStorageId() {
        return this.options.diagramType + ':' + this.options.uri;
    }
    getViewportData() {
        let viewportData = undefined;
        if ((0, client_1.isViewport)(this.editorContext.modelRoot)) {
            viewportData = {
                elementId: this.editorContext.modelRoot.id,
                viewportData: {
                    scroll: this.editorContext.modelRoot.scroll,
                    zoom: this.editorContext.modelRoot.zoom
                }
            };
        }
        return viewportData;
    }
    async setViewportData(viewportData) {
        if (this.actionDispatcher instanceof client_1.GLSPActionDispatcher) {
            const restoreViewportAction = client_1.SetViewportAction.create(viewportData.elementId, viewportData.viewportData, { animate: true });
            return this.actionDispatcher.onceModelInitialized().then(() => this.actionDispatcher.dispatch(restoreViewportAction));
        }
    }
}
exports.GLSPDiagramWidget = GLSPDiagramWidget;
function isViewportDataContainer(obj) {
    return obj !== undefined && obj['elementId'] !== undefined && obj['viewportData'] !== undefined;
}
function getDiagramWidget(widget) {
    if (widget instanceof GLSPDiagramWidget) {
        return widget;
    }
    else if ((0, sprotty_theia_1.isDiagramWidgetContainer)(widget) && widget.diagramWidget instanceof GLSPDiagramWidget) {
        return widget.diagramWidget;
    }
    return undefined;
}
exports.getDiagramWidget = getDiagramWidget;
class SaveableGLSPModelSource {
    constructor(actionDispatcher, modelSource) {
        this.actionDispatcher = actionDispatcher;
        this.modelSource = modelSource;
        this._autoSave = 'off';
        this.autoSaveDelay = 500;
        this.autoSaveJobs = new common_1.DisposableCollection();
        this.isDirty = false;
        this.dirtyChangedEmitter = new common_1.Emitter();
        if (glsp_theia_diagram_server_1.DirtyStateNotifier.is(this.modelSource)) {
            this.modelSource.onDirtyStateChange(dirtyState => (this.dirty = dirtyState.isDirty));
        }
    }
    get onDirtyChanged() {
        return this.dirtyChangedEmitter.event;
    }
    save() {
        return this.actionDispatcher.dispatch(client_1.SaveModelAction.create());
    }
    get dirty() {
        return this.isDirty;
    }
    set dirty(newDirty) {
        const oldValue = this.isDirty;
        if (oldValue !== newDirty) {
            this.isDirty = newDirty;
            this.dirtyChangedEmitter.fire(undefined);
        }
        this.scheduleAutoSave();
    }
    set autoSave(autoSave) {
        this._autoSave = autoSave;
        if (this.shouldAutoSave) {
            this.scheduleAutoSave();
        }
        else {
            this.autoSaveJobs.dispose();
        }
    }
    get autoSave() {
        return this._autoSave;
    }
    scheduleAutoSave() {
        if (this.shouldAutoSave) {
            this.autoSaveJobs.dispose();
            const autoSaveJob = window.setTimeout(() => this.doAutoSave(), this.autoSaveDelay);
            const disposableAutoSaveJob = common_1.Disposable.create(() => window.clearTimeout(autoSaveJob));
            this.autoSaveJobs.push(disposableAutoSaveJob);
        }
    }
    doAutoSave() {
        if (this.shouldAutoSave) {
            this.save();
        }
    }
    get shouldAutoSave() {
        return this.dirty && this.autoSave !== 'off';
    }
    // Needs to be implemented to pass the type check of `WorkspaceFrontendContribution.canBeSaved`.
    async revert(options) {
        console.warn('GLSP only supports server-side saving. The `revert` implementation is no-op and has no effect.');
    }
    // Needs to be implemented to pass the type check of `WorkspaceFrontendContribution.canBeSaved`.
    createSnapshot() {
        throw new Error('GLSP only supports server-side saving. `createSnapshot` should never be invoked');
    }
    dispose() {
        this.autoSaveJobs.dispose();
        this.dirtyChangedEmitter.dispose();
    }
}
exports.SaveableGLSPModelSource = SaveableGLSPModelSource;
//# sourceMappingURL=glsp-diagram-widget.js.map