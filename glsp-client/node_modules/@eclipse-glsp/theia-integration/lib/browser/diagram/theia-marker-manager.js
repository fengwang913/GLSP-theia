"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TheiaMarkerManager = exports.connectTheiaMarkerManager = exports.TheiaMarkerManagerFactory = void 0;
/********************************************************************************
 * Copyright (c) 2020-2021 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const lib_1 = require("@eclipse-glsp/client/lib");
const uri_1 = require("@theia/core/lib/common/uri");
const inversify_1 = require("@theia/core/shared/inversify");
const problem_manager_1 = require("@theia/markers/lib/browser/problem/problem-manager");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const theia_opener_options_navigation_service_1 = require("../theia-opener-options-navigation-service");
exports.TheiaMarkerManagerFactory = Symbol('TheiaMarkerManagerFactory');
function connectTheiaMarkerManager(container, markerManagerFactory, languageLabel) {
    const markerManager = markerManagerFactory();
    if (markerManager instanceof lib_1.ExternalMarkerManager) {
        if (container.isBound(lib_1.ExternalMarkerManager)) {
            container.rebind(lib_1.ExternalMarkerManager).toConstantValue(markerManager);
        }
        else {
            container.bind(lib_1.ExternalMarkerManager).toConstantValue(markerManager);
        }
        markerManager.languageLabel = languageLabel;
        markerManager.connect(container.get(lib_1.TYPES.IActionDispatcher));
    }
}
exports.connectTheiaMarkerManager = connectTheiaMarkerManager;
class DiagnosticMarkers {
    constructor() {
        this.diagnotic2marker = new Map();
    }
    get size() {
        return this.diagnotic2marker.size;
    }
    all() {
        return this.diagnotic2marker.values();
    }
    marker(diagnostic) {
        return this.diagnotic2marker.get(diagnostic);
    }
    add(diagnostic, marker) {
        return this.diagnotic2marker.set(diagnostic, marker);
    }
    delete(diagnostic) {
        return this.diagnotic2marker.delete(diagnostic);
    }
    clear() {
        return this.diagnotic2marker.clear();
    }
}
let TheiaMarkerManager = class TheiaMarkerManager extends lib_1.ExternalMarkerManager {
    constructor() {
        super(...arguments);
        this.uri2markers = new Map();
    }
    markers(uri) {
        const marker = this.uri2markers.get(uri);
        if (marker === undefined) {
            const newMarker = new DiagnosticMarkers();
            this.uri2markers.set(uri, newMarker);
            return newMarker;
        }
        return marker;
    }
    initialize() {
        if (this.problemManager) {
            this.problemManager.onDidChangeMarkers(uri => this.refreshMarker(uri));
        }
    }
    async refreshMarker(uri) {
        if (this.problemManager === undefined || this.markers(uri).size < 1) {
            return;
        }
        const toDelete = [...this.markers(uri).all()];
        for (const existingMarker of this.problemManager.findMarkers({ uri })) {
            const diagnostic = existingMarker.data;
            const marker = this.markers(uri).marker(diagnostic);
            if (marker) {
                const index = toDelete.indexOf(marker);
                if (index > -1) {
                    toDelete.splice(index, 1);
                }
                else {
                    this.markers(uri).delete(diagnostic);
                }
            }
        }
        if (toDelete.length > 0) {
            this.removeMarkers(toDelete);
        }
    }
    setMarkers(markers, sourceUri) {
        if (this.problemManager === undefined) {
            return;
        }
        const uri = new uri_1.default(sourceUri);
        this.markers(uri).clear();
        this.problemManager.setMarkers(uri, this.languageLabel, markers.map(marker => this.createDiagnostic(uri, marker)));
    }
    createDiagnostic(uri, marker) {
        const range = theia_opener_options_navigation_service_1.SelectionWithElementIds.createRange([marker.elementId]);
        const diagnostic = vscode_languageserver_types_1.Diagnostic.create(range, marker.label, this.toSeverity(marker.kind));
        this.markers(uri).add(diagnostic, marker);
        return diagnostic;
    }
    toSeverity(kind) {
        switch (kind) {
            case lib_1.MarkerKind.ERROR:
                return 1;
            case lib_1.MarkerKind.WARNING:
                return 2;
            case lib_1.MarkerKind.INFO:
                return 3;
            default:
                return undefined;
        }
    }
};
__decorate([
    (0, inversify_1.inject)(problem_manager_1.ProblemManager),
    (0, inversify_1.optional)(),
    __metadata("design:type", problem_manager_1.ProblemManager)
], TheiaMarkerManager.prototype, "problemManager", void 0);
__decorate([
    (0, inversify_1.postConstruct)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], TheiaMarkerManager.prototype, "initialize", null);
TheiaMarkerManager = __decorate([
    (0, inversify_1.injectable)()
], TheiaMarkerManager);
exports.TheiaMarkerManager = TheiaMarkerManager;
//# sourceMappingURL=theia-marker-manager.js.map