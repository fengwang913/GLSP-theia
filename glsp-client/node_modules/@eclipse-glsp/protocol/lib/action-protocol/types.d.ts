/********************************************************************************
 * Copyright (c) 2021-2022 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
import * as sprotty from 'sprotty-protocol';
import { Dimension, Point } from 'sprotty-protocol';
import { Action } from './base-protocol';
import { TriggerEdgeCreationAction, TriggerNodeCreationAction } from './tool-palette';
/**
 * A key-value pair structure for primitive typed custom arguments.
 */
export interface Args {
    [key: string]: sprotty.JsonPrimitive;
}
/**
 * The ElementAndBounds type is used to associate new bounds with a model element, which is referenced via its id.
 */
export interface ElementAndBounds extends sprotty.ElementAndBounds {
    /**
     * The identifier of the element.
     */
    elementId: string;
    /**
     * The new size of the element.
     */
    newSize: Dimension;
    /**
     * The new position of the element.
     */
    newPosition?: Point;
}
/**
 * The `ElementAndAlignment` type is used to associate a new alignment with a model element, which is referenced via its id.
 * Typically used to align label relative to their parent element.
 */
export interface ElementAndAlignment extends sprotty.ElementAndAlignment {
    /**
     * The identifier of the element.
     */
    elementId: string;
    /**
     * The new alignment of the element.
     */
    newAlignment: Point;
}
/**
 * The `ElementAndRoutingPoints` type is used to associate an edge with specific routing points.
 */
export interface ElementAndRoutingPoints {
    /**
     * The identifier of an element.
     */
    elementId: string;
    /**
     * The new list of routing points.
     */
    newRoutingPoints?: Point[];
}
/**
 * The `EditorContext` may be used to represent the current state of the editor for particular actions.
 * It encompasses the last recorded mouse position, the list of selected elements, and may contain
 * custom arguments to encode additional state information.
 */
export interface EditorContext {
    /**
     * The list of selected element identifiers.
     */
    readonly selectedElementIds: string[];
    /**
     * The last recorded mouse position.
     */
    readonly lastMousePosition?: Point;
    /**
     * Custom arguments.
     */
    readonly args?: Args;
}
export declare namespace EditorContext {
    function is(object: any): object is EditorContext;
}
/**
 * Labeled actions are used to denote a group of actions in a user-interface context, e.g., to define an entry in the command palette or
 * in the context menu.
 * The corresponding namespace offers a helper function for type guard checks.
 */
export interface LabeledAction {
    /**
     * Group label.
     */
    label: string;
    /**
     * Actions in the group.
     */
    actions: Action[];
    /**
     * Optional group icon.
     */
    icon?: string;
}
export declare namespace LabeledAction {
    function is(object: any): object is LabeledAction;
    function toActionArray(input: LabeledAction | Action[] | Action): Action[];
}
/**
 * A special {@link LabeledAction} that is used to denote actions that should be triggered when the user
 * click a tool palette item (e.g. a button to create a new node).,
 */
export interface PaletteItem extends LabeledAction {
    /** Technical id of the palette item. */
    readonly id: string;
    /** String indicating the order. */
    readonly sortString: string;
    /** Children of this item. If this item has children, the client will know to render them as sub group. */
    readonly children?: PaletteItem[];
}
export declare namespace PaletteItem {
    function is(object: any): object is PaletteItem;
    function getTriggerAction(item?: PaletteItem): TriggerElementCreationAction | undefined;
    type TriggerElementCreationAction = TriggerEdgeCreationAction | TriggerNodeCreationAction;
    function isTriggerElementCreationAction(object: any): object is TriggerElementCreationAction;
}
/**
 * A special {@link LabeledAction} that is used to denote items in a menu.
 */
export interface MenuItem extends LabeledAction {
    /** Technical id of the menu item. */
    readonly id: string;
    /** String indicating the order. */
    readonly sortString?: string;
    /** String indicating the grouping (separators). Items with equal group will be in the same group. */
    readonly group?: string;
    /**
     * The optional parent id can be used to add this element as a child of another element provided by another menu provider.
     * The `parentId` must be fully qualified in the form of `a.b.c`, whereas `a`, `b` and `c` are referring to the IDs of other elements.
     * Note that this attribute will only be considered for root items of a provider and not for children of provided items.
     */
    readonly parentId?: string;
    /** Function determining whether the element is enabled. */
    readonly isEnabled?: () => boolean;
    /** Function determining whether the element is visible. */
    readonly isVisible?: () => boolean;
    /** Function determining whether the element is toggled on or off. */
    readonly isToggled?: () => boolean;
    /** Children of this item. If this item has children, they will be added into a submenu of this item. */
    children?: MenuItem[];
}
export declare namespace MenuItem {
    function is(object: any): object is MenuItem;
}
//# sourceMappingURL=types.d.ts.map