"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PointPositionUpdater = exports.GridSnapper = void 0;
const inversify_1 = require("inversify");
const sprotty_1 = require("sprotty");
/**
 * A {@link ISnapper} implementation that snaps all elements onto a fixed gride size.
 * The default grid size is 10x10 pixel.
 * To configure a custom grid size  bind the `TYPES.ISnapper` service identifier
 * to constant value, e.g:
 *
 * ```ts
 * bind(TYPES.ISnapper).toConstantValue(new GridSnapper({x:25 ,y:25 }));
 * ```
 */
let GridSnapper = class GridSnapper {
    constructor(grid = { x: 10, y: 10 }) {
        this.grid = grid;
    }
    snap(position, element) {
        return {
            x: Math.round(position.x / this.grid.x) * this.grid.x,
            y: Math.round(position.y / this.grid.y) * this.grid.y
        };
    }
};
GridSnapper = __decorate([
    (0, inversify_1.injectable)(),
    __metadata("design:paramtypes", [Object])
], GridSnapper);
exports.GridSnapper = GridSnapper;
/**
 * This class can be used to calculate the current position, when an element is
 * moved. This includes node movements, node resizing (resize handle movement)
 * or edge routing-point movements.
 *
 * You can initialize a this class with a optional {@link ISnapper}. If a
 * snapper is present, the positions will be snapped to the defined grid.
 */
class PointPositionUpdater {
    constructor(snapper) {
        this.snapper = snapper;
        this.positionDelta = { x: 0, y: 0 };
    }
    /**
     * Init the position with the {@link Point} of your mouse cursor.
     * This method is normally called in the `mouseDown` event.
     * @param mousePosition current mouse position e.g `{x: event.pageX, y: event.pageY }`
     */
    updateLastDragPosition(mousePosition) {
        this.lastDragPosition = mousePosition;
    }
    /**
     * Check if the mouse is currently not in a drag mode.
     * @returns true if the last drag position is undefined
     */
    isLastDragPositionUndefined() {
        return this.lastDragPosition === undefined;
    }
    /**
     * Reset the updater for new movements.
     * This method is normally called in the `mouseUp` event.
     */
    resetPosition() {
        this.lastDragPosition = undefined;
        this.positionDelta = { x: 0, y: 0 };
    }
    /**
     * Calculate the current position of your movement.
     * This method is normally called in the `mouseMove` event.
     * @param target node which is moved around
     * @param mousePosition current mouse position e.g `{x: event.pageX, y: event.pageY }`
     * @param isSnapEnabled if a snapper is defined you can disable it, e.g when a specific key is pressed `!event.altKey`
     * @returns current position or undefined if updater has no last drag position initialized
     */
    updatePosition(target, mousePosition, isSnapEnabled) {
        var _a;
        if (this.lastDragPosition) {
            const newDragPosition = mousePosition;
            const viewport = (0, sprotty_1.findParentByFeature)(target, sprotty_1.isViewport);
            const zoom = (_a = viewport === null || viewport === void 0 ? void 0 : viewport.zoom) !== null && _a !== void 0 ? _a : 1;
            const dx = (mousePosition.x - this.lastDragPosition.x) / zoom;
            const dy = (mousePosition.y - this.lastDragPosition.y) / zoom;
            const deltaToLastPosition = { x: dx, y: dy };
            this.lastDragPosition = newDragPosition;
            // update position delta with latest delta
            this.positionDelta.x += deltaToLastPosition.x;
            this.positionDelta.y += deltaToLastPosition.y;
            // snap our delta and only send update if the position actually changes
            // otherwise accumulate delta until we do snap to an update
            const positionUpdate = this.snap(this.positionDelta, target, isSnapEnabled);
            if (positionUpdate.x === 0 && positionUpdate.y === 0) {
                return undefined;
            }
            // we update our position so we update our delta by the snapped position
            this.positionDelta.x -= positionUpdate.x;
            this.positionDelta.y -= positionUpdate.y;
            return positionUpdate;
        }
        return undefined;
    }
    snap(position, element, isSnap) {
        return isSnap && this.snapper ? this.snapper.snap(position, element) : { x: position.x, y: position.y };
    }
}
exports.PointPositionUpdater = PointPositionUpdater;
//# sourceMappingURL=snap.js.map