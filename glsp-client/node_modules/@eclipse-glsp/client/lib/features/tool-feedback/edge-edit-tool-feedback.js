"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FeedbackEdgeRouteMovingMouseListener = exports.FeedbackEdgeSourceMovingMouseListener = exports.FeedbackEdgeTargetMovingMouseListener = exports.DrawFeedbackEdgeSourceCommand = exports.DrawFeedbackEdgeSourceAction = exports.SwitchRoutingModeCommand = exports.SwitchRoutingModeAction = exports.HideEdgeReconnectHandlesFeedbackCommand = exports.ShowEdgeReconnectHandlesFeedbackCommand = exports.HideEdgeReconnectHandlesFeedbackAction = exports.ShowEdgeReconnectHandlesFeedbackAction = void 0;
/********************************************************************************
 * Copyright (c) 2019-2022 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = require("@eclipse-glsp/protocol");
const inversify_1 = require("inversify");
const sprotty_1 = require("sprotty");
const smodel_util_1 = require("../../utils/smodel-util");
const viewpoint_util_1 = require("../../utils/viewpoint-util");
const snap_1 = require("../change-bounds/snap");
const model_1 = require("../reconnect/model");
const creation_tool_feedback_1 = require("./creation-tool-feedback");
const model_2 = require("./model");
var ShowEdgeReconnectHandlesFeedbackAction;
(function (ShowEdgeReconnectHandlesFeedbackAction) {
    ShowEdgeReconnectHandlesFeedbackAction.KIND = 'showReconnectHandlesFeedback';
    function is(object) {
        return protocol_1.Action.hasKind(object, ShowEdgeReconnectHandlesFeedbackAction.KIND);
    }
    ShowEdgeReconnectHandlesFeedbackAction.is = is;
    function create(elementId) {
        return { kind: ShowEdgeReconnectHandlesFeedbackAction.KIND, elementId };
    }
    ShowEdgeReconnectHandlesFeedbackAction.create = create;
})(ShowEdgeReconnectHandlesFeedbackAction = exports.ShowEdgeReconnectHandlesFeedbackAction || (exports.ShowEdgeReconnectHandlesFeedbackAction = {}));
var HideEdgeReconnectHandlesFeedbackAction;
(function (HideEdgeReconnectHandlesFeedbackAction) {
    HideEdgeReconnectHandlesFeedbackAction.KIND = 'hideReconnectHandlesFeedback';
    function is(object) {
        return protocol_1.Action.hasKind(object, HideEdgeReconnectHandlesFeedbackAction.KIND);
    }
    HideEdgeReconnectHandlesFeedbackAction.is = is;
    function create() {
        return { kind: HideEdgeReconnectHandlesFeedbackAction.KIND };
    }
    HideEdgeReconnectHandlesFeedbackAction.create = create;
})(HideEdgeReconnectHandlesFeedbackAction = exports.HideEdgeReconnectHandlesFeedbackAction || (exports.HideEdgeReconnectHandlesFeedbackAction = {}));
let ShowEdgeReconnectHandlesFeedbackCommand = class ShowEdgeReconnectHandlesFeedbackCommand extends model_2.FeedbackCommand {
    constructor(action) {
        super();
        this.action = action;
    }
    execute(context) {
        const index = context.root.index;
        (0, smodel_util_1.forEachElement)(index, smodel_util_1.isRoutable, model_1.removeReconnectHandles);
        const routableElement = index.getById(this.action.elementId);
        if (routableElement && (0, smodel_util_1.isRoutable)(routableElement)) {
            (0, model_1.addReconnectHandles)(routableElement);
        }
        return context.root;
    }
};
ShowEdgeReconnectHandlesFeedbackCommand.KIND = ShowEdgeReconnectHandlesFeedbackAction.KIND;
ShowEdgeReconnectHandlesFeedbackCommand = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
    __metadata("design:paramtypes", [Object])
], ShowEdgeReconnectHandlesFeedbackCommand);
exports.ShowEdgeReconnectHandlesFeedbackCommand = ShowEdgeReconnectHandlesFeedbackCommand;
let HideEdgeReconnectHandlesFeedbackCommand = class HideEdgeReconnectHandlesFeedbackCommand extends model_2.FeedbackCommand {
    constructor(action) {
        super();
        this.action = action;
    }
    execute(context) {
        const index = context.root.index;
        (0, smodel_util_1.forEachElement)(index, smodel_util_1.isRoutable, model_1.removeReconnectHandles);
        return context.root;
    }
};
HideEdgeReconnectHandlesFeedbackCommand.KIND = HideEdgeReconnectHandlesFeedbackAction.KIND;
HideEdgeReconnectHandlesFeedbackCommand = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
    __metadata("design:paramtypes", [Object])
], HideEdgeReconnectHandlesFeedbackCommand);
exports.HideEdgeReconnectHandlesFeedbackCommand = HideEdgeReconnectHandlesFeedbackCommand;
var SwitchRoutingModeAction;
(function (SwitchRoutingModeAction) {
    SwitchRoutingModeAction.KIND = 'switchRoutingMode';
    function create(options) {
        return Object.assign(Object.assign({}, sprotty_1.SwitchEditModeAction.create(options)), { kind: SwitchRoutingModeAction.KIND });
    }
    SwitchRoutingModeAction.create = create;
})(SwitchRoutingModeAction = exports.SwitchRoutingModeAction || (exports.SwitchRoutingModeAction = {}));
let SwitchRoutingModeCommand = class SwitchRoutingModeCommand extends sprotty_1.SwitchEditModeCommand {
    constructor(action) {
        super(Object.assign(Object.assign({}, action), { kind: sprotty_1.SwitchEditModeAction.KIND }));
    }
};
SwitchRoutingModeCommand.KIND = SwitchRoutingModeAction.KIND;
SwitchRoutingModeCommand = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
    __metadata("design:paramtypes", [Object])
], SwitchRoutingModeCommand);
exports.SwitchRoutingModeCommand = SwitchRoutingModeCommand;
var DrawFeedbackEdgeSourceAction;
(function (DrawFeedbackEdgeSourceAction) {
    DrawFeedbackEdgeSourceAction.KIND = 'drawFeedbackEdgeSource';
    function is(object) {
        return protocol_1.Action.hasKind(object, DrawFeedbackEdgeSourceAction.KIND) && (0, protocol_1.hasStringProp)(object, 'elementTypeId') && (0, protocol_1.hasStringProp)(object, 'targetId');
    }
    DrawFeedbackEdgeSourceAction.is = is;
    function create(options) {
        return Object.assign({ kind: DrawFeedbackEdgeSourceAction.KIND }, options);
    }
    DrawFeedbackEdgeSourceAction.create = create;
})(DrawFeedbackEdgeSourceAction = exports.DrawFeedbackEdgeSourceAction || (exports.DrawFeedbackEdgeSourceAction = {}));
let DrawFeedbackEdgeSourceCommand = class DrawFeedbackEdgeSourceCommand extends model_2.FeedbackCommand {
    constructor(action) {
        super();
        this.action = action;
    }
    execute(context) {
        drawFeedbackEdgeSource(context, this.action.targetId, this.action.elementTypeId);
        return context.root;
    }
};
DrawFeedbackEdgeSourceCommand.KIND = DrawFeedbackEdgeSourceAction.KIND;
DrawFeedbackEdgeSourceCommand = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
    __metadata("design:paramtypes", [Object])
], DrawFeedbackEdgeSourceCommand);
exports.DrawFeedbackEdgeSourceCommand = DrawFeedbackEdgeSourceCommand;
/**
 * SOURCE AND TARGET MOUSE MOVE LISTENER
 */
class FeedbackEdgeTargetMovingMouseListener extends creation_tool_feedback_1.FeedbackEdgeEndMovingMouseListener {
    constructor(anchorRegistry) {
        super(anchorRegistry);
        this.anchorRegistry = anchorRegistry;
    }
}
exports.FeedbackEdgeTargetMovingMouseListener = FeedbackEdgeTargetMovingMouseListener;
class FeedbackEdgeSourceMovingMouseListener extends sprotty_1.MouseListener {
    constructor(anchorRegistry) {
        super();
        this.anchorRegistry = anchorRegistry;
    }
    mouseMove(target, event) {
        const root = target.root;
        const edgeEnd = root.index.getById((0, creation_tool_feedback_1.feedbackEdgeEndId)(root));
        if (!(edgeEnd instanceof creation_tool_feedback_1.FeedbackEdgeEnd) || !edgeEnd.feedbackEdge) {
            return [];
        }
        const edge = edgeEnd.feedbackEdge;
        const position = (0, viewpoint_util_1.getAbsolutePosition)(edgeEnd, event);
        const endAtMousePosition = (0, sprotty_1.findChildrenAtPosition)(target.root, position).find(e => (0, sprotty_1.isConnectable)(e) && e.canConnect(edge, 'source'));
        if (endAtMousePosition instanceof sprotty_1.SConnectableElement && edge.target && (0, sprotty_1.isBoundsAware)(edge.target)) {
            const anchor = this.computeAbsoluteAnchor(endAtMousePosition, protocol_1.Bounds.center(edge.target.bounds));
            if (protocol_1.Point.euclideanDistance(anchor, edgeEnd.position) > 1) {
                return [sprotty_1.MoveAction.create([{ elementId: edgeEnd.id, toPosition: anchor }], { animate: false })];
            }
        }
        else {
            return [sprotty_1.MoveAction.create([{ elementId: edgeEnd.id, toPosition: position }], { animate: false })];
        }
        return [];
    }
    computeAbsoluteAnchor(element, referencePoint, offset) {
        const anchorComputer = this.anchorRegistry.get(sprotty_1.PolylineEdgeRouter.KIND, element.anchorKind);
        let anchor = anchorComputer.getAnchor(element, referencePoint, offset);
        // The anchor is computed in the local coordinate system of the element.
        // If the element is a nested child element we have to add the absolute position of its parent to the anchor.
        if (element.parent !== element.root) {
            const parent = (0, sprotty_1.findParentByFeature)(element.parent, sprotty_1.isBoundsAware);
            if (parent) {
                const absoluteParentPosition = (0, viewpoint_util_1.toAbsoluteBounds)(parent);
                anchor = protocol_1.Point.add(absoluteParentPosition, anchor);
            }
        }
        return anchor;
    }
}
exports.FeedbackEdgeSourceMovingMouseListener = FeedbackEdgeSourceMovingMouseListener;
class FeedbackEdgeRouteMovingMouseListener extends sprotty_1.MouseListener {
    constructor(edgeRouterRegistry, snapper) {
        super();
        this.edgeRouterRegistry = edgeRouterRegistry;
        this.snapper = snapper;
        this.pointPositionUpdater = new snap_1.PointPositionUpdater(snapper);
    }
    mouseDown(target, event) {
        const result = [];
        if (event.button === 0) {
            const routingHandle = (0, sprotty_1.findParentByFeature)(target, smodel_util_1.isRoutingHandle);
            if (routingHandle !== undefined) {
                result.push(SwitchRoutingModeAction.create({ elementsToActivate: [target.id] }));
                this.pointPositionUpdater.updateLastDragPosition({ x: event.pageX, y: event.pageY });
            }
            else {
                this.pointPositionUpdater.resetPosition();
            }
        }
        return result;
    }
    mouseMove(target, event) {
        const result = [];
        if (event.buttons === 0) {
            return this.mouseUp(target, event);
        }
        const positionUpdate = this.pointPositionUpdater.updatePosition(target, { x: event.pageX, y: event.pageY }, !event.altKey);
        if (positionUpdate) {
            const moveActions = this.handleMoveOnClient(target, positionUpdate, !event.altKey);
            result.push(...moveActions);
        }
        return result;
    }
    handleMoveOnClient(target, positionUpdate, isSnap) {
        const handleMoves = [];
        target.root.index
            .all()
            .filter(element => (0, sprotty_1.isSelected)(element))
            .forEach(element => {
            if ((0, smodel_util_1.isRoutingHandle)(element)) {
                const elementMove = this.toElementMove(element, positionUpdate, isSnap);
                if (elementMove) {
                    handleMoves.push(elementMove);
                }
            }
        });
        if (handleMoves.length > 0) {
            return [sprotty_1.MoveAction.create(handleMoves, { animate: false })];
        }
        return [];
    }
    toElementMove(element, positionDelta, isSnap) {
        const point = this.getHandlePosition(element);
        if (point !== undefined) {
            const snappedPoint = this.getSnappedHandlePosition(element, point, isSnap);
            return {
                elementId: element.id,
                fromPosition: point,
                toPosition: {
                    x: snappedPoint.x + positionDelta.x,
                    y: snappedPoint.y + positionDelta.y
                }
            };
        }
        return undefined;
    }
    getSnappedHandlePosition(element, point, isSnap) {
        if (this.snapper && isSnap) {
            return this.snapper.snap(point, element);
        }
        return point;
    }
    getHandlePosition(handle) {
        if (this.edgeRouterRegistry) {
            const parent = handle.parent;
            if (!(0, smodel_util_1.isRoutable)(parent)) {
                return undefined;
            }
            const router = this.edgeRouterRegistry.get(parent.routerKind);
            const route = router.route(parent);
            return router.getHandlePosition(parent, route, handle);
        }
        return undefined;
    }
    mouseEnter(target, event) {
        if (target instanceof sprotty_1.SModelRoot && event.buttons === 0) {
            this.mouseUp(target, event);
        }
        return [];
    }
    mouseUp(_target, event) {
        this.pointPositionUpdater.resetPosition();
        return [];
    }
    decorate(vnode, _element) {
        return vnode;
    }
}
exports.FeedbackEdgeRouteMovingMouseListener = FeedbackEdgeRouteMovingMouseListener;
/**
 * UTILITY FUNCTIONS
 */
function drawFeedbackEdgeSource(context, targetId, elementTypeId) {
    const root = context.root;
    const targetChild = root.index.getById(targetId);
    if (!targetChild) {
        return;
    }
    const target = (0, sprotty_1.findParentByFeature)(targetChild, sprotty_1.isConnectable);
    if (!target || !(0, sprotty_1.isBoundsAware)(target)) {
        return;
    }
    const edgeEnd = new creation_tool_feedback_1.FeedbackEdgeEnd(target.id, elementTypeId);
    edgeEnd.id = (0, creation_tool_feedback_1.feedbackEdgeEndId)(root);
    edgeEnd.position = { x: target.bounds.x, y: target.bounds.y };
    const feedbackEdgeSchema = {
        type: 'edge',
        id: (0, creation_tool_feedback_1.feedbackEdgeId)(root),
        sourceId: edgeEnd.id,
        targetId: target.id,
        opacity: 0.3
    };
    const feedbackEdge = context.modelFactory.createElement(feedbackEdgeSchema);
    if ((0, smodel_util_1.isRoutable)(feedbackEdge)) {
        edgeEnd.feedbackEdge = feedbackEdge;
        root.add(edgeEnd);
        root.add(feedbackEdge);
    }
}
//# sourceMappingURL=edge-edit-tool-feedback.js.map