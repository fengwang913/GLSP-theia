"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeFeedbackEdge = exports.drawFeedbackEdge = exports.defaultFeedbackEdgeSchema = exports.feedbackEdgeEndId = exports.feedbackEdgeId = exports.FeedbackEdgeEndMovingMouseListener = exports.FeedbackEdgeEnd = exports.RemoveFeedbackEdgeCommand = exports.RemoveFeedbackEdgeAction = exports.DrawFeedbackEdgeCommand = exports.DrawFeedbackEdgeAction = void 0;
/********************************************************************************
 * Copyright (c) 2019-2022 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const protocol_1 = require("@eclipse-glsp/protocol");
const inversify_1 = require("inversify");
const sprotty_1 = require("sprotty");
const smodel_util_1 = require("../../utils/smodel-util");
const viewpoint_util_1 = require("../../utils/viewpoint-util");
const model_1 = require("./model");
var DrawFeedbackEdgeAction;
(function (DrawFeedbackEdgeAction) {
    DrawFeedbackEdgeAction.KIND = 'drawFeedbackEdge';
    function is(object) {
        return protocol_1.Action.hasKind(object, DrawFeedbackEdgeAction.KIND);
    }
    DrawFeedbackEdgeAction.is = is;
    function create(options) {
        return Object.assign({ kind: DrawFeedbackEdgeAction.KIND }, options);
    }
    DrawFeedbackEdgeAction.create = create;
})(DrawFeedbackEdgeAction = exports.DrawFeedbackEdgeAction || (exports.DrawFeedbackEdgeAction = {}));
let DrawFeedbackEdgeCommand = class DrawFeedbackEdgeCommand extends model_1.FeedbackCommand {
    constructor(action) {
        super();
        this.action = action;
    }
    execute(context) {
        const feedbackEdgeSchema = this.action.edgeSchema ? this.action.edgeSchema : exports.defaultFeedbackEdgeSchema;
        drawFeedbackEdge(context, this.action.sourceId, this.action.elementTypeId, feedbackEdgeSchema);
        return context.root;
    }
};
DrawFeedbackEdgeCommand.KIND = DrawFeedbackEdgeAction.KIND;
DrawFeedbackEdgeCommand = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
    __metadata("design:paramtypes", [Object])
], DrawFeedbackEdgeCommand);
exports.DrawFeedbackEdgeCommand = DrawFeedbackEdgeCommand;
var RemoveFeedbackEdgeAction;
(function (RemoveFeedbackEdgeAction) {
    RemoveFeedbackEdgeAction.KIND = 'removeFeedbackEdgeCommand';
    function is(object) {
        return protocol_1.Action.hasKind(object, RemoveFeedbackEdgeAction.KIND);
    }
    RemoveFeedbackEdgeAction.is = is;
    function create() {
        return { kind: RemoveFeedbackEdgeAction.KIND };
    }
    RemoveFeedbackEdgeAction.create = create;
})(RemoveFeedbackEdgeAction = exports.RemoveFeedbackEdgeAction || (exports.RemoveFeedbackEdgeAction = {}));
let RemoveFeedbackEdgeCommand = class RemoveFeedbackEdgeCommand extends model_1.FeedbackCommand {
    execute(context) {
        removeFeedbackEdge(context.root);
        return context.root;
    }
};
RemoveFeedbackEdgeCommand.KIND = RemoveFeedbackEdgeAction.KIND;
RemoveFeedbackEdgeCommand = __decorate([
    (0, inversify_1.injectable)()
], RemoveFeedbackEdgeCommand);
exports.RemoveFeedbackEdgeCommand = RemoveFeedbackEdgeCommand;
class FeedbackEdgeEnd extends sprotty_1.SDanglingAnchor {
    constructor(sourceId, elementTypeId, feedbackEdge = undefined, type = FeedbackEdgeEnd.TYPE) {
        super();
        this.sourceId = sourceId;
        this.elementTypeId = elementTypeId;
        this.feedbackEdge = feedbackEdge;
        this.type = type;
    }
}
exports.FeedbackEdgeEnd = FeedbackEdgeEnd;
FeedbackEdgeEnd.TYPE = 'feedback-edge-end';
class FeedbackEdgeEndMovingMouseListener extends sprotty_1.MouseListener {
    constructor(anchorRegistry) {
        super();
        this.anchorRegistry = anchorRegistry;
    }
    mouseMove(target, event) {
        const root = target.root;
        const edgeEnd = root.index.getById(feedbackEdgeEndId(root));
        if (!(edgeEnd instanceof FeedbackEdgeEnd) || !edgeEnd.feedbackEdge) {
            return [];
        }
        const edge = edgeEnd.feedbackEdge;
        const position = (0, viewpoint_util_1.getAbsolutePosition)(edgeEnd, event);
        const endAtMousePosition = (0, sprotty_1.findChildrenAtPosition)(target.root, position)
            .reverse()
            .find(element => (0, sprotty_1.isConnectable)(element) && element.canConnect(edge, 'target'));
        if (endAtMousePosition instanceof sprotty_1.SConnectableElement && edge.source && (0, sprotty_1.isBoundsAware)(edge.source)) {
            const anchor = this.computeAbsoluteAnchor(endAtMousePosition, protocol_1.Bounds.center((0, viewpoint_util_1.toAbsoluteBounds)(edge.source)));
            if (protocol_1.Point.euclideanDistance(anchor, edgeEnd.position) > 1) {
                return [sprotty_1.MoveAction.create([{ elementId: edgeEnd.id, toPosition: anchor }], { animate: false })];
            }
        }
        else {
            return [sprotty_1.MoveAction.create([{ elementId: edgeEnd.id, toPosition: position }], { animate: false })];
        }
        return [];
    }
    computeAbsoluteAnchor(element, absoluteReferencePoint, offset) {
        const referencePointInParent = absoluteToParent(element, absoluteReferencePoint);
        const anchorComputer = this.anchorRegistry.get(sprotty_1.PolylineEdgeRouter.KIND, element.anchorKind);
        let anchor = anchorComputer.getAnchor(element, referencePointInParent, offset);
        // The anchor is computed in the local coordinate system of the element.
        // If the element is a nested child element we have to add the absolute position of its parent to the anchor.
        if (element.parent !== element.root) {
            const parent = (0, sprotty_1.findParentByFeature)(element.parent, sprotty_1.isBoundsAware);
            if (parent) {
                const absoluteParentPosition = (0, viewpoint_util_1.toAbsoluteBounds)(parent);
                anchor = protocol_1.Point.add(absoluteParentPosition, anchor);
            }
        }
        return anchor;
    }
}
exports.FeedbackEdgeEndMovingMouseListener = FeedbackEdgeEndMovingMouseListener;
/**
 * Convert a point, specified in absolute coordinates, to a point relative
 * to the parent of the specified child element.
 * @param element the child element
 * @param absolutePoint a point in absolute coordinates
 * @returns the equivalent point, relative to the element's parent coordinates
 */
function absoluteToParent(element, absolutePoint) {
    if ((0, sprotty_1.isBoundsAware)(element.parent)) {
        return absoluteToLocal(element.parent, absolutePoint);
    }
    // If the parent is not bounds-aware, assume it's at 0; 0 and proceed
    return absoluteToLocal(element, absolutePoint);
}
/**
 * Convert a point, specified in absolute coordinates, to a point relative
 * to the specified element.
 * @param element the element
 * @param absolutePoint a point in absolute coordinates
 * @returns the equivalent point, relative to the element's coordinates
 */
function absoluteToLocal(element, absolutePoint) {
    const absoluteElementBounds = (0, viewpoint_util_1.toAbsoluteBounds)(element);
    return { x: absolutePoint.x - absoluteElementBounds.x, y: absolutePoint.y - absoluteElementBounds.y };
}
function feedbackEdgeId(root) {
    return root.id + '_feedback_edge';
}
exports.feedbackEdgeId = feedbackEdgeId;
function feedbackEdgeEndId(root) {
    return root.id + '_feedback_anchor';
}
exports.feedbackEdgeEndId = feedbackEdgeEndId;
exports.defaultFeedbackEdgeSchema = {
    cssClasses: ['feedback-edge'],
    opacity: 0.3
};
function drawFeedbackEdge(context, sourceId, elementTypeId, feedbackEdgeSchema) {
    const root = context.root;
    const sourceChild = root.index.getById(sourceId);
    if (!sourceChild) {
        return;
    }
    const source = (0, sprotty_1.findParentByFeature)(sourceChild, sprotty_1.isConnectable);
    if (!source || !(0, sprotty_1.isBoundsAware)(source)) {
        return;
    }
    const edgeEnd = new FeedbackEdgeEnd(source.id, elementTypeId);
    edgeEnd.id = feedbackEdgeEndId(root);
    edgeEnd.position = (0, viewpoint_util_1.toAbsolutePosition)(source);
    feedbackEdgeSchema.id = feedbackEdgeId(root);
    feedbackEdgeSchema.type = elementTypeId;
    feedbackEdgeSchema.sourceId = source.id;
    feedbackEdgeSchema.targetId = edgeEnd.id;
    const feedbackEdge = context.modelFactory.createElement(feedbackEdgeSchema);
    if ((0, smodel_util_1.isRoutable)(feedbackEdge)) {
        edgeEnd.feedbackEdge = feedbackEdge;
        root.add(edgeEnd);
        root.add(feedbackEdge);
    }
}
exports.drawFeedbackEdge = drawFeedbackEdge;
function removeFeedbackEdge(root) {
    const feedbackEdge = root.index.getById(feedbackEdgeId(root));
    const feedbackEdgeEnd = root.index.getById(feedbackEdgeEndId(root));
    if (feedbackEdge instanceof sprotty_1.SChildElement) {
        root.remove(feedbackEdge);
    }
    if (feedbackEdgeEnd instanceof sprotty_1.SChildElement) {
        root.remove(feedbackEdgeEnd);
    }
}
exports.removeFeedbackEdge = removeFeedbackEdge;
//# sourceMappingURL=creation-tool-feedback.js.map